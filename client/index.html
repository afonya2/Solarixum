<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Solarixum Test Page</title>
        <style>
            body {
                background-color: #0a1428;
                color: #ebf0fa;
            }
        </style>
    </head>
    <body>
        <input type="text" placeholder="Username" id="username">
        <input type="password" placeholder="Password" id="password">
        <button onclick="register()">Register</button>
        <hr>
        <input type="text" placeholder="Token" id="token">
        <input type="text" placeholder="Recovery word" id="recoveryWord">
        <input type="password" placeholder="Password" id="recPass">
        <button onclick="recover()">Recover</button>
        <script>
            const PROT_NAME = 'Solarixum Protocol';
            const PROT_VER = '0.1.0';
            function generateRandomString(length) {
                const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                return result;
            }
            function keyToHex(key) {
                return Array.from(new Uint8Array(key)).map(b => b.toString(16).padStart(2, '0')).join('')
            }
            function hexToKey(hex) {
                return new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            }
            async function passwordToIV(password) {
                const encoder = new TextEncoder();
                const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(password));
                return new Uint8Array(hashBuffer.slice(0, 16));
            }
            async function derivePasswordKey(password) {
                const encoder = new TextEncoder();
                const hash = await crypto.subtle.digest('SHA-256', encoder.encode(password));
                return await crypto.subtle.importKey(
                    'raw',
                    hash,
                    { name: 'AES-CBC' },
                    false,
                    ['encrypt', 'decrypt']
                );
            }
            async function register() {
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                const recoveryWord = generateRandomString(32);
                console.log("Recovery word:", recoveryWord);
                
                let key = await crypto.subtle.generateKey({
                    name: "RSA-OAEP",
                    modulusLength: 4096,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                    hash: "SHA-256"
                }, true, ["encrypt", "decrypt"]);
                let exportedPrivKey = await crypto.subtle.exportKey("pkcs8", key.privateKey);
                console.log("Private Key:", keyToHex(exportedPrivKey));
                let iv = await passwordToIV(password)
                console.log("IV:", keyToHex(iv));
                let keyBuffer = await crypto.subtle.importKey("raw", new TextEncoder().encode(recoveryWord), { name: "AES-CBC" }, false, ["encrypt"]);
                let encryptedPrivKey = await crypto.subtle.encrypt({
                    name: "AES-CBC",
                    iv: iv
                }, keyBuffer, exportedPrivKey);
                let privateKeyHex = keyToHex(encryptedPrivKey);
                let exportedPubKey = await crypto.subtle.exportKey("spki", key.publicKey);
                let publicKeyHex = keyToHex(exportedPubKey);

                let req = await fetch('/api/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password, privateKey: privateKeyHex, publicKey: publicKeyHex, protocol: PROT_NAME, protocolVersion: PROT_VER })
                });
                let res = await req.json();
                if (!res.ok) {
                    console.error("Registration failed:", res.error);
                    return;
                }
                console.log(res);

                localStorage.setItem("token", res.body.token);
                let keyBuffer2 = await derivePasswordKey(password);
                let encryptedPrivKey2 = await crypto.subtle.encrypt({
                    name: "AES-CBC",
                    iv: iv
                }, keyBuffer2, exportedPrivKey);
                localStorage.setItem("privateKey", keyToHex(encryptedPrivKey2));
                localStorage.setItem("publicKey", publicKeyHex);
            }
            async function recover() {
                const token = document.getElementById('token').value;
                const recoveryWord = document.getElementById('recoveryWord').value;
                const password = document.getElementById('recPass').value;

                let req = await fetch('/api/recover', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ token, protocol: PROT_NAME, protocolVersion: PROT_VER })
                });
                let res = await req.json();
                if (!res.ok) {
                    console.error("Recovery failed:", res.error);
                    return;
                }
                console.log(res);
                let encryptedPrivKey = hexToKey(res.body.privateKey);
                let publicKey = hexToKey(res.body.publicKey);
                let keyBuffer = await crypto.subtle.importKey("raw", new TextEncoder().encode(recoveryWord), { name: "AES-CBC" }, false, ["decrypt"]);
                let iv = await passwordToIV(password);
                console.log("IV:", keyToHex(iv));
                let decryptedPrivKey = await crypto.subtle.decrypt({
                    name: "AES-CBC",
                    iv: iv
                }, keyBuffer, encryptedPrivKey);
                let privateKey = await crypto.subtle.importKey("pkcs8", decryptedPrivKey, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["decrypt"]);
                let importedPublicKey = await crypto.subtle.importKey("spki", publicKey, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]);
                console.log("Private Key:", keyToHex(decryptedPrivKey));

                let keyBuffer2 = await derivePasswordKey(password);
                let encryptedPrivKey2 = await crypto.subtle.encrypt({
                    name: "AES-CBC",
                    iv: iv
                }, keyBuffer2, decryptedPrivKey);
                localStorage.setItem("privateKey", keyToHex(encryptedPrivKey2));
                localStorage.setItem("publicKey", keyToHex(publicKey));
            }
        </script>
    </body>
</html>